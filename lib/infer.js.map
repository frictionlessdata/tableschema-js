{"version":3,"sources":["../src/infer.js"],"names":[],"mappings":";;;;;;AAAA;;IAAY,C;;AACZ;;IAAY,K;;;;;;;;;;;;;;;;;;;kBAgBG,UAAC,OAAD,EAAU,MAAV,EAAmC;AAAA,MAAjB,OAAiB,yDAAP,EAAO;;;AAEhD,MAAM,OAAO,EAAE,MAAF,CACX;AACE,cAAU,IADZ;AAEI,cAAU,KAFd;AAGI,gBAAY,IAHhB;AAII,UAAM;AAJV,GADW,EAMR,OANQ,CAAb;MAOI,UAAU,IAAI,MAAM,WAAV,CAAsB,KAAK,IAA3B,CAPd;MAQI,SAAS,EAAE,QAAQ,EAAV,EARb;;AAUA,MAAI,KAAK,UAAT,EAAqB;AACnB,WAAO,UAAP,GAAoB,KAAK,UAAzB;AACD;;AAED,SAAO,MAAP,GAAgB,QAAQ,GAAR,CAAY,kBAAU;AACpC,QAAM,cAAc,EAApB;QACI,aAAa;AACf,YAAM,MADS;AAEb,aAAO,EAFM;AAGb,mBAAa;AAHA,KADjB;;AAOA,QAAI,KAAK,QAAT,EAAmB;AACjB,kBAAY,QAAZ,GAAuB,IAAvB;AACD;;AAED,QAAI,WAAW,KAAK,UAApB,EAAgC;AAC9B,kBAAY,MAAZ,GAAqB,IAArB;AACD;;AAED,QAAI,CAAC,EAAE,OAAF,CAAU,WAAV,CAAL,EAA6B;AAC3B,iBAAW,WAAX,GAAyB,WAAzB;AACD;;AAED,WAAO,UAAP;AACD,GArBe,CAAhB;;AAuBA,UAAQ,OAAR,CAAgB,UAAC,MAAD,EAAS,KAAT,EAAmB;AACjC,QAAI,eAAe,EAAE,KAAF,CAAQ,MAAR,EAAgB,KAAhB,CAAnB;;AAEA,QAAI,KAAK,QAAT,EAAmB;AACjB,qBAAe,EAAE,KAAF,CAAQ,YAAR,EAAsB,KAAK,QAA3B,CAAf;AACD;;AAED,WAAO,MAAP,CAAc,KAAd,IAAuB,EAAE,MAAF,CAAS,OAAO,MAAP,CAAc,KAAd,CAAT,EAA+B;AACpD,YAAM,QAAQ,SAAR,CAAkB,YAAlB,CAD8C;AAElD,cAAQ;AAF0C,KAA/B,CAAvB;AAID,GAXD;;AAaA,SAAO,MAAP;AACD,C","file":"infer.js","sourcesContent":["import * as _ from 'underscore'\nimport * as types from './types'\n\n/**\n * Return a schema from the passed headers and values.\n *\n * @param headers {Array} - a list of header names\n * @param values {Array} - a reader over data, yielding each row as a list of\n *   values\n * @param options {Object}:\n *  - {integer} rowLimit - limit amount of rows to be proceed\n *  - {boolean} explicit - be explicit\n *  - {string} primaryKey - pass in a primary key or iterable of keys\n *  - {object} cast - TODO add description\n *\n * @returns {object} a JSON Table Schema as a Python dict\n */\nexport default (headers, values, options = {}) => {\n  // Set up default options\n  const opts = _.extend(\n    {\n      rowLimit: null\n      , explicit: false\n      , primaryKey: null\n      , cast: {}\n    }, options)\n    , guesser = new types.TypeGuesser(opts.cast)\n    , schema = { fields: [] }\n\n  if (opts.primaryKey) {\n    schema.primaryKey = opts.primaryKey\n  }\n\n  schema.fields = headers.map(header => {\n    const constraints = {}\n      , descriptor = {\n      name: header\n      , title: ''\n      , description: ''\n    }\n\n    if (opts.explicit) {\n      constraints.required = true\n    }\n\n    if (header === opts.primaryKey) {\n      constraints.unique = true\n    }\n\n    if (!_.isEmpty(constraints)) {\n      descriptor.constraints = constraints\n    }\n\n    return descriptor\n  })\n\n  headers.forEach((header, index) => {\n    let columnValues = _.pluck(values, index)\n\n    if (opts.rowLimit) {\n      columnValues = _.first(columnValues, opts.rowLimit)\n    }\n\n    schema.fields[index] = _.extend(schema.fields[index], {\n      type: guesser.multiCast(columnValues)\n      , format: 'default'\n    })\n  })\n\n  return schema\n}\n"]}