{"version":3,"sources":["../src/models.js"],"names":[],"mappings":"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","file":"models.js","sourcesContent":["import { _ } from 'underscore'\nimport { Promise } from 'bluebird'\nimport ensure from './ensure'\nimport utilities from './utilities'\nimport types from './types'\n\nconst DEFAULTS = {\n  constraints: { required: true }\n  , format: 'default'\n  , type: 'string'\n}\n/**\n * Model for a JSON Table Schema.\n *\n * Providers handy helpers for ingesting, validating and outputting\n * JSON Table Schemas: http://dataprotocols.org/json-table-schema/\n *\n * @param {string|dict} source: A filepath, url or dictionary that represents a\n *   schema\n *\n * @param {boolean} caseInsensitiveHeaders: if True, headers should be\n * considered case insensitive, and `SchemaModel` forces all\n * headers to lowercase when they are represented via a model\n * instance. This setting **does not** mutate the actual strings\n * that come from the the input schema source, so out put methods\n * such as as_python and as_json are **not** subject to this flag.\n */\n\nexport default class SchemaModel {\n  constructor(source, caseInsensitiveHeaders = false) {\n    this.source = source\n    this.caseInsensitiveHeaders = caseInsensitiveHeaders\n\n    // Map a JSON Table Schema type to a JTSKit type class\n    this.typeMap = {\n      string: types.StringType\n      , number: types.NumberType\n      , integer: types.IntegerType\n      , boolean: types.BooleanType\n      , null: types.NullType\n      , array: types.ArrayType\n      , object: types.ObjectType\n      , date: types.DateType\n      , time: types.TimeType\n      , datetime: types.DateTimeType\n      , geopoint: types.GeoPointType\n      , geojson: types.GeoJSONType\n      , any: types.AnyType\n    }\n\n    const asJs = this.toJs()\n\n    // Manually use .loadSource() to get schema in case of URL passed instead of\n    // schema\n    if (asJs instanceof Promise) {\n      this.schemaPromise = asJs\n    } else {\n      this.validateAndExpand(asJs)\n    }\n  }\n\n  /**\n   * Check if value can be cast to fieldName's type\n   *\n   * @param fieldName\n   * @param value\n   * @param index\n   *\n   * @returns {Boolean}\n   */\n  cast(fieldName, value, index) {\n    return this.getType(fieldName, index || 0).cast(value)\n  }\n\n  /**\n   * Expand the schema with additional default properties\n   *\n   * @param schema\n   * @returns {*}\n   */\n  expand(schema) {\n    return _.extend(\n      schema\n      , {\n        fields: (schema.fields || []).map((field) => {\n          const copyField = _.extend({}, field)\n\n          // Ensure we have a default type if no type was declared\n          if (!copyField.type) {\n            copyField.type = DEFAULTS.type\n          }\n\n          // Ensure we have a default format if no format was\n          // declared\n          if (!copyField.format) {\n            copyField.format = DEFAULTS.format\n          }\n\n          // Ensure we have a minimum constraints declaration\n          if (!copyField.constraints) {\n            copyField.constraints = DEFAULTS.constraints\n          } else if (_.isUndefined(field.constraints.required)) {\n            copyField.constraints.required =\n              DEFAULTS.constraints.required\n          }\n          return copyField\n        })\n      })\n  }\n\n  fields() {\n    return this.asJs.fields\n  }\n\n  foreignKeys() {\n    return this.asJs.foreignKeys\n  }\n\n  /**\n   * Return the `constraints` object for `fieldName`.\n   * @param {string} fieldName\n   * @param {integer} index\n   * @returns {object}\n   */\n  getConstraints(fieldName, index = 0) {\n    return this.getField(fieldName, index).constraints\n  }\n\n  // Return the `field` object for `fieldName`.\n  // `index` allows accessing a field name by position, as JTS allows\n  // duplicate field names.\n  getField(fieldName, index = 0) {\n    try {\n      return _.where(this.fields(), { name: fieldName })[index]\n    } catch (e) {\n      return null\n    }\n  }\n\n  // Return all fields that match the given type.\n  getFieldsByType(typeName) {\n    return _.where(this.fields(), { type: typeName })\n  }\n\n  // Return the `type` for `fieldName`.\n  getType(fieldName, index) {\n    const field = this.getField(fieldName, index || 0)\n    return this.typeMap[field.type](field)\n  }\n\n  /**\n   * Check if the field exists in the schema\n   *\n   * @param fieldName\n   * @returns {boolean}\n   */\n  hasField(fieldName) {\n    return Boolean(this.getField(fieldName))\n  }\n\n  headers() {\n    const raw = _.chain(this.asJs.fields).map(_.property('name')).value()\n\n    if (this.caseInsensitiveHeaders) {\n      return _.invoke(raw, 'toLowerCase')\n    }\n    return raw\n  }\n\n  // Load schema from URL passed in init\n  loadSchema() {\n    return this.schemaPromise.then(this.validateAndExpand)\n  }\n\n  primaryKey() {\n    return this.asJs.primaryKey\n  }\n\n  requiredHeaders() {\n    const raw = _.chain(this.asJs.fields)\n      .filter(field => field.constraints.required)\n      .map(_.property('name'))\n      .value()\n\n    if (this.caseInsensitiveHeaders) {\n      return _.invoke(raw, 'toLowerCase')\n    }\n\n    return raw\n  }\n\n  // Return schema as an Object.\n  toJs() {\n    try {\n      return utilities.loadJSONSource(this.source)\n    } catch (e) {\n      return null\n    }\n  }\n\n  validateAndExpand(value) {\n    if (_.isUndefined(value) || _.isNull(value)) {\n      throw new Error('Invalid JSON')\n    }\n\n    if (!ensure(value)[0]) {\n      throw new Error('Invalid schema')\n    }\n\n    this.asJs = this.expand(value)\n\n    return this\n  }\n}\n"]}