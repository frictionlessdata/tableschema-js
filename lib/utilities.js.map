{"version":3,"sources":["../src/utilities.js"],"names":[],"mappings":";;AAAA,IAAM,IAAI,QAAQ,YAAR,CAAV;IACI,UAAU,QAAQ,UAAR,CADd;IAEI,UAAU,QAAQ,YAAR,CAFd;IAGI,MAAM,QAAQ,KAAR,CAHV;;AAKA,UAAU,OAAO,OAAP,GAAiB;AACzB,kBAAgB,CAAC,MAAD,EAAS,OAAT,EAAkB,KAAlB,EAAyB,MAAzB,CADS;AAEvB,eAAa,CAAC,MAAD,EAAS,MAAT,EAAiB,KAAjB,EAAwB,KAAxB,EAA+B,GAA/B,EAAoC,EAApC,CAFU;AAGvB,eAAa,CAAC,KAAD,EAAQ,GAAR,EAAa,MAAb,EAAqB,GAArB,EAA0B,GAA1B,CAHU;AAIvB,gBAAc,CAAC,IAAD,EAAO,GAAP,EAAY,OAAZ,EAAqB,GAArB,EAA0B,GAA1B,CAJS;;AAMvB,QANuB,kBAMhB,KANgB,EAMT;AACd,WAAO,EAAE,QAAF,CAAW,KAAX,KAAqB,CAAC,EAAE,OAAF,CAAU,KAAV,CAAtB,IAA0C,CAAC,EAAE,UAAF,CAAa,KAAb,CAAlD;AACD;;;AARwB;AAWvB,gBAXuB,0BAWR,MAXQ,EAWA;AACvB,QAAI,EAAE,MAAF,CAAS,MAAT,KAAoB,EAAE,WAAF,CAAc,MAAd,CAAxB,EAA+C;AAC7C,aAAO,IAAP;AACD,KAFD,MAEO,IAAI,EAAE,QAAF,CAAW,MAAX,KAAsB,CAAC,EAAE,UAAF,CAAa,MAAb,CAA3B,EAAiD;;;AAGtD,aAAO,MAAP;AACD;;AAED,QAAI,EAAE,QAAF,CAAW,KAAK,cAAhB,EACW,IAAI,KAAJ,CAAU,MAAV,EAAkB,QAAlB,CAA2B,OAA3B,CAAmC,GAAnC,EAAwC,EAAxC,CADX,CAAJ,EAC6D;AAC3D,aAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAqB;AACtC,gBAAQ,GAAR,CAAY,MAAZ,EAAoB,GAApB,CAAwB,UAAC,KAAD,EAAQ,QAAR,EAAqB;AAC3C,cAAI,KAAJ,EAAW;AACT,iEAA4C,KAA5C;AACD,WAFD,MAEO;AACL,oBAAQ,KAAK,KAAL,CAAW,QAAX,CAAR;AACD;AACF,SAND;AAOD,OARM,CAAP;AASD;;;AAGF;AAlCwB,CAA3B","file":"utilities.js","sourcesContent":["const _ = require('underscore')\n  , Promise = require('bluebird')\n  , request = require('superagent')\n  , url = require('url')\n\nexports = module.exports = {\n  REMOTE_SCHEMES: ['http', 'https', 'ftp', 'ftps']\n  , NULL_VALUES: ['null', 'none', 'nil', 'nan', '-', '']\n  , TRUE_VALUES: ['yes', 'y', 'true', 't', '1']\n  , FALSE_VALUES: ['no', 'n', 'false', 'f', '0']\n\n  , isHash(value) {\n    return _.isObject(value) && !_.isArray(value) && !_.isFunction(value)\n  }\n\n  // Load a JSON source, from string, URL or buffer, into a Python type.\n  , loadJSONSource(source) {\n    if (_.isNull(source) || _.isUndefined(source)) {\n      return null\n    } else if (_.isObject(source) && !_.isFunction(source)) {\n      // The source has already been loaded. Return Promise object for\n      // consistency.\n      return source\n    }\n\n    if (_.contains(this.REMOTE_SCHEMES,\n                   url.parse(source).protocol.replace(':', ''))) {\n      return new Promise((resolve, reject) => {\n        request.get(source).end((error, response) => {\n          if (error) {\n            reject(`Failed to download registry file: ${error}`)\n          } else {\n            resolve(JSON.parse(response))\n          }\n        })\n      })\n    }\n    // WARN There is no possibility to have browser compatable code which can\n    // load file\n  }\n}\n"]}