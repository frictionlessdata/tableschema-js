{"version":3,"sources":["../src/ensure.js"],"names":[],"mappings":"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","file":"ensure.js","sourcesContent":["import { _ } from 'underscore'\nimport utilities from './utilities'\n\n/**\n Validate that `schema` is a valid JSON Table Schema.\n\n Args:\n * `schema`: a dict to check if it is valid JSON Table Schema\n\n Returns:\n * A tuple of `valid`, `errors`\n */\nexport default (schema) => {\n  const fieldsNames = _.map(_.result(schema, 'fields') || [],\n                            _.property('name'))\n\n  let valid = true\n    , errors = []\n\n  // A schema is a hash\n  if (!utilities.isHash(schema)) {\n    valid = false\n    addError('should be a hash.')\n\n    // Return early in this case.\n    return [valid, errors]\n  }\n\n  // Which MUST contain a key `fields`\n  if (!schema.fields) {\n    valid = false\n    addError('must have a fields key.')\n\n    // Return early in this case.\n    return [valid, errors]\n  }\n\n  // `fields` MUST be an array\n  if (!_.isArray(schema.fields)) {\n    valid = false\n    addError('must have an array of fields.')\n\n    // Return early in this case.\n    return [valid, errors]\n  }\n\n  // Each entry in the `fields` array MUST be a hash\n  if (!_.every(schema.fields, (field) => utilities.isHash(field))) {\n    valid = false\n    addError('Each field in JSON Table Schema must be a hash.', false)\n  }\n\n  // Each entry in the `fields` array MUST have a `name` key\n  if (!_.every(schema.fields, (field) => Boolean(field.name))) {\n    valid = false\n    addError('field must have a name key.')\n  }\n\n  // Each entry in the `fields` array MAY have a `constraints` key\n  // if `constraints` is present, then `constraints` MUST be a hash\n  if (!_.every(schema.fields,\n               (field) => !field.constraints ||\n                          utilities.isHash(field.constraints)\n    )) {\n    valid = false\n    errors =\n      addError('field constraint must be a hash.')\n  }\n\n  // Constraints may contain certain keys (each has a specific meaning)\n  _.chain(schema.fields).filter((field) => Boolean(field.constraints))\n    .each((field) => {\n      // IF `required` key, then it is a boolean\n      if (field.constraints.required &&\n          !_.isBoolean(field.constraints.required)) {\n        valid = false\n        addError('required constraint must be a boolean.')\n      }\n\n      // IF `minLength` key, then it is an integer\n      if (field.constraints.minLength &&\n          !_.isNumber(field.constraints.minLength)) {\n        valid = false\n        addError('minLength constraint must be an integer.')\n      }\n\n      // IF `maxLength` key, then it is an integer\n      if (field.constraints.maxLength &&\n          !_.isNumber(field.constraints.maxLength)) {\n        valid = false\n        addError('maxLength constraint must be an integer')\n      }\n\n      // IF `unique` key, then it is a boolean\n      if (field.constraints.unique && !_.isBoolean(field.constraints.unique)) {\n        valid = false\n        addError('unique constraint must be a boolean.')\n      }\n\n      // IF `pattern` key, then it is a regex\n      if (field.constraints.pattern && !_.isString(field.constraints.pattern)) {\n        valid = false\n        addError('pattern constraint must be a string.')\n      }\n\n      // IF `minimum` key, then it DEPENDS on `field` TYPE\n      if (field.constraints.minimum) {\n        // IF `type` is integer\n        if (_.isNumber(field.type) && !_.isNumber(field.constraints.minimum)) {\n          valid = false\n          addError('minimum constraint which is an integer is only valid if ' +\n                   'the encompassing field is also of type integer')\n        }\n\n        // WARN Probably need to chack for moment() type if we decide to go\n        // with moment() for dates IF `type` is date\n        else if (_.isDate(field.type) && !_.isDate(field.constraints.minimum)) {\n          valid = false\n          addError('minimum constraint which is a date is only valid if the ' +\n                   'encompassing field is also of type date')\n        } else {\n          valid = false\n          addError('minimum constraint is present with unclear application' +\n                   ' (field is not an integer or a date)')\n        }\n      }\n\n      if (field.constraints.maximum) {\n        // IF `type` is integer\n        if (_.isNumber(field.type) && !_.isNumber(field.constraints.maximum)) {\n          valid = false\n          addError('maximum constraint which is an integer is only valid if' +\n                   ' the encompassing field is also of type integer')\n        }\n        // WARN Probably need to check for moment() type if we decide to go\n        // with moment() for dates IF `type` is date\n        else if (_.isDate(field.type) && !_.isDate(field.constraints.maximum)) {\n          valid = false\n          addError('maximum constraint which is a date is only valid if the' +\n                   ' encompassing field is also of type date')\n        } else {\n          valid = false\n          addError('maximum constraint is present with unclear application' +\n                   ' (field is not an integer or a date)')\n        }\n      }\n    })\n\n  // The hash MAY contain a key `primaryKey`\n  if (schema.primaryKey) {\n    // `primaryKey` MUST be a string or an array\n    if (!(_.isString(schema.primaryKey) || _.isArray(schema.primaryKey))) {\n      valid = false\n      addError('primaryKey must be either a string or an array.')\n    }\n\n    // Ensure that the primary key matches field names\n    if (_.isString(schema.primaryKey)) {\n      if (!_.contains(fieldsNames, schema.primaryKey)) {\n        valid = false\n        addError('primaryKey value must be found in the schema field names')\n      }\n    } else {\n      _.each(schema.primaryKey, (PK) => {\n        if (_.contains(fieldsNames, PK)) {\n          valid = false\n          addError('primaryKey value must be found in the schema field names')\n        }\n      })\n    }\n  }\n\n  // The hash may contain a key `foreignKeys`\n  if (schema.foreignKeys) {\n    // `foreignKeys` MUST be an array\n    if (!_.isArray(schema.foreignKeys)) {\n      valid = false\n      addError('foreignKeys must be an array.')\n    }\n\n    // Each `foreignKey` in `foreignKeys` MUST be a hash\n    if (!_.every(schema.foreignKeys, FK => utilities.isHash(FK))) {\n      valid = false\n      addError('`foreignKey` must be a hash.')\n    }\n\n    // Each `foreignKey` in `foreignKeys` MUST have a `fields` key\n    if (!_.every(schema.foreignKeys, FK => Boolean(FK.fields))) {\n      valid = false\n      addError('foreignKey must have a fields key.')\n    }\n\n    // Each `fields` key in a `foreignKey` MUST be a string or array\n    if (!_.every(schema.foreignKeys,\n                 FK => _.isString(FK.fields) || _.isArray(FK.fields))) {\n      valid = false\n      addError('foreignKey.fields type must be a string or an array.')\n    }\n\n    _.each(schema.foreignKeys, (FK) => {\n      // Ensure that `foreignKey.fields` match field names\n      if (_.isString(FK.fields)) {\n        if (!_.contains(fieldsNames, FK.fields)) {\n          valid = false\n          addError('foreignKey.fields value must correspond with field names.')\n        }\n      } else {\n        if ((_.intersection(fieldsNames, FK.fields) || []).length <\n            FK.fields.length) {\n          valid = false\n          addError('foreignKey.fields value must correspond with field names.')\n        }\n      }\n\n      // Ensure that `foreignKey.reference` is present and is a hash\n      if (!utilities.isHash(FK.reference)) {\n        valid = false\n        addError('foreignKey.reference must be a hash.')\n      }\n\n      // Ensure that `foreignKey.reference` has a `resource` key\n      if (!_.contains(_.keys(FK.reference), 'resource')) {\n        valid = false\n        addError('foreignKey.reference must have a resource key.')\n      }\n\n      // Ensure that `foreignKey.reference` has a `fields` key\n      if (!_.contains(_.keys(FK.reference), 'fields')) {\n        valid = false\n        addError('foreignKey.reference must have a fields key.')\n      }\n\n      // Ensure that `foreignKey.reference.fields` matches outer `fields`\n      if (_.isString(FK.fields)) {\n        if (!_.isString(FK.reference.fields)) {\n          valid = false\n          addError('foreignKey.reference.fields must match field names.')\n        }\n      } else {\n        if (FK.fields.length !== FK.reference.fields.length) {\n          valid = false\n          addError('must have a fields key.')\n        }\n      }\n    })\n  }\n\n  return [valid, errors]\n\n  function addError(error, isSuffix = true) {\n    if (isSuffix) {\n      errors.push(`A JSON Table Schema ${error}`)\n    } else {\n      errors.push(error)\n    }\n  }\n}\n\n//module.exports = ensure\n"]}